
# Java 线程池
java通过Executors提供四种基本的线程池

- newCachedThreadPool 可以缓存的线程池
- newFixedThreadPool 定长线程池
- newScheduledThreadPool 定长线程池 周期性执行任务
- newSingleThreadExecutor 单一线程的线程池。


##ThreadPoolExecutor
```
new  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);
```
参数说明：

- corePoolSize 线程池的基本大小
- runnableTaskQueue 任务队列
    - ArrayBlockingQueue
    - LinkedBlockingQueue
    - SynchronousQueue
    - LinkedBlockingQueue
    - PriorityBlockingQueue

##join 方法详解
- public final void join(long millis，int nanos)
    等待至多millis毫秒+nanos纳秒之后线程结束
- public final void join(long millis) throws InterruptedException
    等待至多millis毫秒之后线程结束, 0表示永远的等待。
- public final void join() throws InterruptedException
- 
    等待该线程结束

thread.join() 把指定的线程【thread】加入到当前的线程，可以将两个交替指定的线程合并为顺序执行的线程，比如在线程B中调用A的join()方法，直到线程A执行完成后，机会继续执行线程B。

```
    public class JoinTest implements Runnable{
        public static int a = 0;
        public void run(){
            for(int k= 0;k<5;k++){
                a = a +1;
            }
        }

        public static void main(String[] args){
            Runnable r = new JoinTest();
            Thread t = new Thread(r);
            t.start();
            t.join();// 等待t执行完成之后，主线程【main】才会继续执行
            t.join(1000);// mian等待1000毫秒之后继续执行，不管t有没有执行完成
            System.out.println(a);
        }
    }
```

##synchronized
 某个对象的实例 synchronized aMethod(){},防止某个多线程 同时访问这个对象的synchronized方法
类范围的锁 synchronized static aMethod(){},防止多线程同时访问类中的 synchronized static 方法。
 
 synchronized关键字是不能继承的，也就是说 父类synchronized方法 到子类中不是自动synchronized，需要显示指定。
 无论 synchronized关键字加载方法上 还是对象上，他去的锁都是对象，而不是把一段代码或者函数当做锁

 [Synchronized关键字总结](http://uule.iteye.com/blog/1104562)