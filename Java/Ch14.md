# Ch14 类型信息
***运行时类型信息使得你可以在程序运行时
时发现和使用类型信息***

运行时识别对象和类信息的两种方式：

- 传统的RTTI，他假定我们在编译时已经知道了所有的类型
- 反射 它允许我们在运行时发现和使用类的信息。

##14.1 为什么需要RTTI
多态：通过泛化类型来引用调用派生类的方法，也能产生正确的行为。
向上转型时也会丢失具体对象的类型。
List<Shape> 保存的都是Shape，***在编译时是由容器和Java的泛型系统来强制确保这一点的；在运行时，由类型转换操作来确保这一点***

##14.2 Class 对象

###14.2.1 类字面常量
Java 还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。
使用字面常量不仅简单而且还安全，因为在编译时就会受到检查（因此不需要至于try、catch语句中）。

使用“.class”来创建对Class对象的引用时***不会自动的初始化该Class对象***。要使用该类而要做的准备工作实际分为三步
>1. 加载
>由类加载器执行，该步骤将查找字节码（通常子啊classpath指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个Class对象。
>
>2. 链接
>验证类中的字节码，为静态域分配存储空间，并且如果有必要的话，将解析这个类创建的对其他类的所有的引用。
>
>3. 初始化
>如果该类具有超类，则对齐初始化，执行静态初始化器和静态初始化块。



##Tips
1. 如果某个对象出现在字符串的表达式中（涉及“+”和字符创对象的表达式），toString方法都会被自动调用，以生成表示该对象的String
2. RTTI : Run-Time Type Identification
3. static ***块初始化是在类加载时（编译时？OR 编译之后加载的？【有待解答验证】）进行的***


