# Ch14 类型信息
***运行时类型信息使得你可以在程序运行时
时发现和使用类型信息***

运行时识别对象和类信息的两种方式：

- 传统的RTTI，他假定我们在编译时已经知道了所有的类型
- 反射 它允许我们在运行时发现和使用类的信息。

##14.1 为什么需要RTTI
多态：通过泛化类型来引用调用派生类的方法，也能产生正确的行为。
向上转型时也会丢失具体对象的类型。
List<Shape> 保存的都是Shape，***在编译时是由容器和Java的泛型系统来强制确保这一点的；在运行时，由类型转换操作来确保这一点***

##14.2 Class 对象

###14.2.1 类字面常量
Java 还提供了另一种方法来生成对Class对象的引用，即使用类字面常量。
使用字面常量不仅简单而且还安全，因为在编译时就会受到检查（因此不需要至于try、catch语句中）。

使用“.class”来创建对Class对象的引用时***不会自动的初始化该Class对象***。要使用该类而要做的准备工作实际分为三步
>1. 加载
>由类加载器执行，该步骤将查找字节码（通常子啊classpath指定的路径中查找，但这并非是必须的），并从这些字节码中创建一个Class对象。
>
>2. 链接
>验证类中的字节码，为静态域分配存储空间，并且如果有必要的话，将解析这个类创建的对其他类的所有的引用。
>
>3. 初始化
>如果该类具有超类，则对齐初始化，执行静态初始化器和静态初始化块。



##Tips
1. 如果某个对象出现在字符串的表达式中（涉及“+”和字符创对象的表达式），toString方法都会被自动调用，以生成表示该对象的String
2. RTTI : Run-Time Type Identification
3. static ***块初始化是在类加载时（编译时？OR 编译之后加载的？【有待解答验证】）进行的***

###14.2.2 泛化的Class引用
Java SE5 中引入了泛型机制
通过泛型语法，可以让编译器强制执行额外的类型检查。
为了在使用泛化的Class引用放松限制，我们使用了通配符，他是Java泛型的一部分。
通配符就是`?` 标识任何事物

```
    Class<?> intClass = int.class;
    intClass = double.class;
```
 
为了创建一个Class引用，它被限定为某种类型，或者该类型的任何子类型，**你需要通过讲通配符与extends关键字相结合**，创建一个范围。
例如 `Class<? extends Number> numberType` numberType表示一个只能用来指向Number子类的变量

```
 Class<? extends Number> bound = int.class;
 bound = double.class
```
当泛型应用与Class对象时，newInstance()讲返回该对象的确切类型，如果是超类，那么编译器将只允许声明超类的引用是“某个类”

```
 public class GeneToyTest{
    public static void main(String[] args){
        Class<FancyToy> ftClass = FancyToy.class;
        FanceyToy fancyToy = ftClass.newInstance();

        Class<? super FanctyToy> up = ftClass.getSuperclass();
        //不接受Class<Toy> 这样的声明
        Object obj  = up.newInstance(); 
    }
 }
```

###14.2.3 新的转型语法
Java SE5还添加了用于Class引用的转型语法，即`cast()`方法。cast() 方法接受参数对象，并将其转型为Class的引用的类型。

```
    Building b = new House();
    Class<House> houseType = House.class; 
    House h = HouseType.cast(b);
    //跟 h = (House)b 是一个意思
```

##14.3 类型转换前先做检查

RTTI形式
1. 传统的类型转换
2. 代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息。
类型安全的向下转型 超类转为子类（向下转型 Shape 转为 Circle） 子类转为超类（向上转型 Circle转为Shape），可以自由的向上转型的赋值操作，编译器不允许执行向下转型赋值，不允许想下转型到实际上不是待转型类的子类的类型上。
RRTI 在Java 中还有第三种形式，就是关键字instanceof。他返回一个布尔值，告诉我们对象是不是某个特定类型的事例

```
if(x instanceof Dog)
    ((Dog)x).break();
```

###14.3.1 使用类字面常量

###14.3.2 动态的instanceof
Class.isInstance 方法提供了动态测试类对象的途径。

```
 Userinfo userinfo = new Userinfo();
 Class<Userinfo> userinfoClass = Userinfo.class;
 userinfoClass.isInstance(userinfo);
```

### 14.3.3 递归计数
